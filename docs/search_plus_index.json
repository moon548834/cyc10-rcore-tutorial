{"./":{"url":"./","title":"关于这本书","keywords":"","body":"这是一个关于在cyc10开发板上运行rcore https://rcore-os.github.io/rCore_tutorial_doc 的一些记录。这个gitbook是基于64位记录的，我这里迁移到了32位。 CPU及bbl修改自 https://github.com/shyoshyo/openriscv ，感谢他们之前的工作。 const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"Chap1/1-0-environment.html":{"url":"Chap1/1-0-environment.html","title":"第一章环境配置与运行指南","keywords":"","body":"一些环境搭建说明 本工程在windows10操作系统下进行，涉及到的软件如 Quartus 18.0(prime), modelsim 等均在windows下使用 modelsim在Quartus安装的时候可以勾选一并安装 对于其中涉及到linux的相关操作，全部在WSL(linux子系统ubuntu16.04进行)，当然也可以使用虚拟机操作，不过这样速度会慢一些。需要注意的是WSL默认挂载在C盘，如果C盘空间不足，请更改挂载位置，由于本人只有C盘是固态，所以按照默认方式进行。 在WLS下可以通过 cd /mnt/c/...的方式，迅速的切换到C盘目录(其他盘类推)，之后便可以用命令行的形式在windows下工作，由于本人比较熟悉命令行与vim，所以经常使用此方法。 RISCV交叉编译链 安装命令 $ sudo apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev $ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain $ cd riscv-gnu-toolchain $ ./configure --prefix=/opt/riscv --with-arch=rv32ima --with-abi=ilp32 $ make -j4 arch中的a参数代表原子指令，对于跑操作系统来讲是不可或缺的，另外由于我选用的cpu没有fpu硬件，所以采用ilp32软浮点模拟的功能 由于编译链比较大，且可能会访问一些google源，所以请确保网络通畅，整个 git clone update 过程大约需要持续数小时，编译也是需要数小时，请耐心等待 更详细的参数请参考 https://github.com/riscv/riscv-gnu-toolchain 的说明 添加环境变量 在 ~/.bashrc中添加 PATH=/opt/riscv/bin:$PATH 之后键入 $ source ~/.bashrc 接下来在任何一个地方命令行输入 riscv32 后输入两次 Tab, 应该会有自动补全成 riscv32-unknown-elf- 并显示若干编译链工具，至此编译链安装成功。 如果安装了qemu，可以交叉一个riscv32格式的helloworld，并用qemu-riscv32运行之，用以简单的测试。 运行本工程以及分支介绍 好了，这个时候假定你已经正确地安装好了编译链，下面开始在modelsim下仿真本项目: 由于网速原因，有的时候会很慢，所以可以 git clone -b xxx -depth=1 指定分支clone，一般一个分支不会大于100MB (TODO 整理github减少一些不必要的文件) git clone git@github.com:oscourse-tsinghua/undergraduate-fzpeng2020.git git checkout feature-4MB-bbl-without-compression ./build.sh 注意涉及OS部分操作目前仅支持在仿真环境下运行 好了，接下来打开quartus,由于每个人的modelsim路径不一样，第一次需要设置modelsim的路径 Tools->Options->General->EDA Tool Options下设置相应的路径: 需要注意的是quartus和modelsim的关联设置，这里默认的是modelsim-altera，如是SE版本请自行在Assignments->Setting->EDA TOOL Settings->Simulation->Tool Name下选择合适的仿真版本。 如果改成SE版本需要在 Assignments->Settings->EDA Tool Settings下更改Tool Name 然后点击Tool->Run Simulation Tool->RTL Simualtion 不出问题的话，就应该可以自动跳转到modelsim仿真界面了。 说明： 一般分支下有两个quartus project分别叫wishbone_cyc10, wishbone_cyc10_os,前者测指令，后者测OS 分支: feature-4MB-bbl-without-compression 这个分支对应于仿真环境下(modelsim)可以跑操作系统,只需看wishbone_cyc10_os这个工程即可。对于这个分支而言需要先运行build.sh这样就可以正常仿真了。 分支：master 这个分支下只需要考虑工程wishbone_cyc10即可, 用的是第三方SDRAM IP核，可以下板(SDRAM有8MB,但实际上只有部分空间可以使用)。 分支: sdram_qsys 这个分支下只需考虑工程wishbone_cyc10即可，用的是quartus自带的IP核(和master的不一样), sdram仍有bug。 分支: sdram_naked 无CPU，只是用来测试SDRAM的，里面有一个可以认为是信号发生器的master，逻辑简单，可以用来验证SDRAM(虽然bug未解决)。 const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"Chap2/2-0-hardware.html":{"url":"Chap2/2-0-hardware.html","title":"第二章硬件结构说明","keywords":"","body":"硬件说明 CPU与SOC简单介绍 这个cpu采用的是lkx的工作 http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring/projects/u1 该cpu是经典的5级流水线架构，支持m态和s态特权级，并且具有mmu单元与tlb，无cache设计。 soc则基于《自己动手写CPU》(雷思磊)结构，采用的是wishbone总线，其中sdram使用的是开源代码，uart自己重写(为了节省资源，只支持发送功能，且只有一个端口，波特率写死，无ready位)，片外flash目前尚不清楚如何工作，故采用片内rom，使用intel的.hex文件进行例化。总线交互也采用的是开源代码。 一些背景知识 五级流水架构 这只是一个简单的示意图，如果没有相关的基础知识理解起来还是比较困难的，我这里推荐一本书，名字是《计算机组成与设计——硬件软件接口》作者是Patterson和Hennessy，里面有详细的过于MIPS架构的介绍，事实上MIPS和RISCV从架构上讲都属于精简指令集，而且很多结构都比较相似，所以不必拘泥于一定要找riscv的书。另外如果接触源码的话，之前推荐的雷思磊写的是一本不错的书，不过学习过程不能只是抄源码，还是要多去理解才有更大的收获的。 在这里我结合本工程的CPU简单介绍一下一个指令的执行过程，对于一条指令来讲，在硬件执行的过程中被拆分成了5个阶段，这五个阶段在没有异常和暂停的时候是并行进行的。对于一个指令来说首先在IF阶段更新pc值并从指令ROM中取数据，这个时候由于数据可能需要若干周期，流水线就暂停了，等到请求完毕后将去回来的指令送往ID级，ID级的工作顾名思义就是decode的过程，接下来进入的是EXE也就是执行级，这里面一般会进行一些加减乘除移位的运算操作，然后将结果送往mem级，如果有访存的指令，那么就访问数据ram即可，同理，请求ram可能也需要多周期，此时流水线也停下。执行完毕后数据送往WB级，将结果写回寄存器堆。 需要注意的是，图中并没有标注处理中断异常的特权级，mips中是cp0，riscv中是csr，这个阶段一般都放在mem，一般来讲地址都需要进行mmu转换，一个访问ram的地址，需要先经过csr的一些判断，然后送往tlb，tlb出来的地址再送往(或者cache)内存。针对一些异常的情况，csr这个模块会及时地发出清流水线的命令，并进行相关处理。 riscv的官方手册也是一个很好的帮助，另外国人也有一版电子书(翻译)介绍riscv架构的，在此也一并推荐 http://crva.io/documents/RISC-V-Reader-Chinese-v2p1.pdf wishbone总线 wishbone总线只考虑单次的读写还是比较简单的，上面的端口比如 rst, clk 大多可以顾名思义，在此我也不赘述，握手协议简单地说就是 CYC和STB同时拉高时表示请求开始，在整个过程中，保持高电平，一直等到slave响应ACK拉高后的下一周期，CYC，STB和ACK拉低，至此一个请求结束 这里给一个简单的时序图(来自《自己动手写CPU》)，不考虑TAG信号，更详细资料请参阅 https://cdn.opencores.org/downloads/wbspec_b4.pdf 请注意上升沿1和上升沿0之间实际可能还有若干个周期，并且ACK拉高的那个周期的上升沿CYC和STB还是高电平 FPGA平台 小脚丫STEP-CYC10是一款基于Intel Cyclone10设计的FPGA开发板，芯片型号是10CL016YU256C8G。另外，板卡上集成了USB Blaster编程器、SDRAM、FLASH等多种外设。板上预留了PCIE子卡插座，可方便进行扩展。其板载资源如下： 资源种类 数量 资源种类 数量 LE资源 16000 可扩展 STEP-PCIE接口 1个 片上存储空间 504Kbit 集成 USB Blaster编程器 1个 DSP blocks 56个 SDRAM 64Mbit PLL 4路 Flash 64Mbit Micro USB接口 2路 三轴加速度计 ADXL345 1个 数码管 4位 USB转Uart桥接芯片 CP2102 1个 RGB 三色LED 2个 12M与50M双路时钟源 1个 5向按键 1路 LED 8路 5向按键(?)我当成普通按键处理 SOC整体框图 CONFIG模块对应于 verilog 中 config_string 模块，这个模块存在的目的是为了兼容BBL，其中保存了一些硬件信息供BBL查询设置，另外根据BBL要求，timer与cmp的地址也是通过内存地址访问的，这里也一并归于此模块中。当timer达到cmp的数值时会触发一个定时器中断，直接送往CPU。 硬件地址空间分配 基于以上资源，我将测试环境下的CPU地址分配如下： 设备 地址分布 大小 ROM 0x0001_0000~0x0001_c000 48KB SDRAM 0x0010_0000~0x0050_0000 4MB 串口 0x0200_0000~0x0200_0020 32B LED 0x3000_0000~0x0300_0010 16B CONFIG 0x0000_1000~0x0000_0100 0x4000_0000~0x4000_0010 0x4000_0000~0x4000_0004 256B 16B 4B 该部分可以在 ./wishbone_cyc10/phy_bus_addr_conv.v中找到对应的verilog语句及宏定义，只需修改其中的数值即可。举个例子，如想修改RAM的地址分配，只需要修改以下两个宏即可，其余不需更改。 `define RAM_PHYSICAL_ADDR_BEGIN 34'h00010_0000 `define RAM_PHYSICAL_ADDR_LEN 34'h00040_0000 ROM控制器 相关代码位于 ./wishbone_cyc10/rom_wishbone.v，相关控制比较简单，不赘述，单举一个需要注意的事项，这里我的ROM里面调用了一个已经封装好的IP核，这个IP核的配置为 深度=16384，宽度=32bits，这样算起来一共有64kB，与之前的48KB不符。这是因为IP核深度只能配置为16384/8192，即64KB/32KB，没有中间选项，所以只好如此，但并不影响结果，只要你保证真正用到的rom不超过48KB即可。或者配置为8192也可以，这样程序限制在小于32KB。 仿真环境的RAM控制器 通过开启或关闭 位于./wishbone_cyc10/cpu/defines.v中的宏`define Simulation可以开启或关闭仿真环境，在仿真环境下使用的是如下定义的ram。 reg [`WishboneDataBus] mem[0:`DataMemNum-1]; 这里面 DataMemNum 是一个很大的数，所以综合必定失败，但是由于我们只是用来仿真，所以不必要求综合。但在进行联合仿真的时候 Tools -> Run Simulation Tool -> RTL Simulation，有时系统会报错，大意是必须先进行sythesis再仿真，这时我的做法是把ram中的DataMemNum数值调小，先保证综合成功，然后仿真的时候再改回原来的大数值就可以了。 真实环境的SDRAM控制器 SDRAM结构 注意：实际上文中这个配置并不能跑起整个SDRAM，虽然也确实可以通过rv32ui的官方测例 另外这个方式使用的开源的sdram程序，不是IP核 SDRAM(Synchronous Dynamic Random Access Memory)是同步动态随机访问存储器，同步是指memory工作需要同步时钟，内部命令的发送与数据的传输都以它为基准；动态是指存储阵列需要不断地刷新以保证数据不丢失；随机访问是指数据不是线性依次读写，而是可以自由指定地址进行读/写。 SDRAM的内部有存储单元整列，给出行地址，列地址，就可以选择相应的存储单元，如下图中右侧部分所示。 图上左侧的信号，对应于顶层文件的这些接口，有部分信号芯片手册上未标明如dq。 output wire sdr_clk_o, output wire sdr_cs_n_o, output wire sdr_cke_o, output wire sdr_ras_n_o, output wire sdr_cas_n_o, output wire sdr_we_n_o, output wire [1:0] sdr_dqm_o, output wire [1:0] sdr_ba_o, output wire [11:0] sdr_addr_o, inout wire [15:0] sdr_dq_io, 接口说明如下： 序号 接口名 宽度(bit) 输入/输出 作用 1 ADDR 12 输入 地址线 2 CLK 1 输入 时钟 3 CKE 1 输入 时钟使能 4 RAS 1 输入 行地址选通，低有效 5 CS 1 输入 片选，低有效 6 CAS 1 输入 列地址选通，低有效 7 WE 1 输入 写使能，低有效 8 DQM 2 输入 字节选择和输出使能，低有效 9 DQ 16 双向 数据线 10 BA 2 输入 bank选择 对于SDRAM更深刻的介绍，需要很大的篇幅，由于我们并非需要直接驱动SDRAM，而只需要驱动SDRAM的控制器，所以这里就不再展开，《自己动手写CPU》中关于Flash控制器有更多的描述。这里介绍的目的是，对SDRAM有一个基本的认识即可。 SDRAM控制器 这个SDRAM控制器取自于OpenCores,该SDRAM控制器： 支持SDRAM的数据总线宽度可以为8,16,32 支持4个Bank的SDRAM 自动控制刷新 支持所有标准的SDRAm功能 支持 wishbone B总线 这是一个功能十分完善的控制器，根据说明，在实际使用过程中，无需修改如何源码我们只需配置如下参数就可以用了！ 序号 参数名 宽度(bit) 输入/输出 作用 1 cfg_sdr_width 2 输入 SDRAM的数据总线宽度: 00 —— 32位SDRAM 01 —— 16位SDRAM 1x —— 8位SDRAM 2 cfg_sdr_en 1 输入 SDRAM控制器使能信号 3 cfg_sdr_colbits 2 输入 列地址宽度:00 —— 8bit 01 —— 9bit 10 —— 10bit11 —— 11bit 4 cfg_sdr_mode_reg 13 输入 模式寄存器 5 cfg_sdr_tras_d 4 输入 tRAS的值，单位是时钟周期 6 cfg_sdr_trp_d 4 输入 tRP的值，单位是时钟周期 7 cfg_sdr_trcd_d 4 输入 tRCD的值，单位是时钟周期 8 cfg_sdr_cas 3 输入 CL地值，单位是时钟周期 9 cfg_sdr_trcar_d 4 双向 tRC的值，单位是时钟周期 10 cfg_sdr_twr_d 4 输入 tWR的值，单位是时钟周期 11 cfg_sdr_rfsh 12 输入 自动刷新间隔，单位是时钟周期 12 cfg_sdr_rfmax 3 输入 每次刷新的最大行数 13 cfg_req_depth 2 输入 请求缓存的数量 SDRAM参数确定 那么接下来就是通过查阅手册来确定这些参数了： 前三个比较好确定，宽度是16，所以值是 2'b11； 使能自然是1'b1；列地址宽度是8，所以值是2'b00。 关于模式寄存器的结构如下，或者查阅芯片手册： 模式寄存器配置为 13'b0_0000_0011_0001，表示CAS延时为3个时钟周期，突发长度为2(一次16bits，两次正好32bits)，突发模式是线性。 关于有关时间的参数，见下表，或者查阅芯片手册进行配置。 手册中给出的-5 -6 -7代表了不同频率的设置值，最低的也是133MHz，事实上我在下板的时候用133MHz也会报WNS违约，后来发现降低SDRAM主频也是可以工作的。 参考《自己动手写CPU》cfg_sdr_cas要比模式寄存器中的值大一，故是3'b100。 关于rfsh的配置：芯片45S16400的每个bank有4096行，此处设置每次最大的刷新行数rfmax为4，所以在64ms内要求有 4096/4 = 1024 次刷新。每次刷新的间隔即是(64/1024)ms，SOC使用的时钟频率是30MHz，计算 30 1e6 64 1e-3 / 1024 得到1875，故设置为对应的二进制 12'b011101010011。 cfg_req_depth尚不清楚有何影响，采取和《自己动手写CPU》相同设置未发现错误。 最后的参数如下： .cfg_req_depth(2'b11), .cfg_sdr_en(1'b1), .cfg_sdr_mode_reg(13'b0000000110001), .cfg_sdr_tras_d(4'b1000), .cfg_sdr_trp_d(4'b0010), .cfg_sdr_trcd_d(4'b0010), .cfg_sdr_cas(3'b100), .cfg_sdr_trcar_d(4'b1010), .cfg_sdr_twr_d(4'b0010), .cfg_sdr_rfsh(12'b011101010011), .cfg_sdr_rfmax(3'b100), .cfg_sdr_width(2'b01), .cfg_colbits(2'b00) SDRAM问题 我在使用SDRAM的时候使用了两种方法，但最后都以失败告终，在此记录，如果可能可以帮助到后来者。 方法一、 使用手把手中的sdram开源文件 过程如上节所述，结果是只能使用极其有限的一部分sdram空间可能只有几十KB。 方法二、 使用qsys中的sdram 这种方法参考了lxs中的实现，在它的soc中，全部环境都采用的是200MHz的频率，并且通过quartus的qsys直接搭建，简便明了。使用qsys的SDRAMIP核从他的实验中验证是可以行的通的，那么理论在我这里加一个总线转换桥也是可以跑的。 为什么直接在IP Catalog中搜不到sdram的ip核，我猜测还是由于总线的原因，但至少通过我接下来说的这种方式是可以间接用它的IP核的 打开qsys界面后，只需假如SDRAM的IP核即可，然后将avalon接口和物理的sdram的接口引出，图中对应信号avalon_sdram和sdram,双击一下就可以修改名称，这里必须引出，因为需要和我们的wishbone总线交互。 参数如表，另外需要注意的是左侧信号，sdram对应的信号为zs_xxx，这里和实际的物理sdram接口对应没有问题，而对应的avalon总线，注意地址是[21:0]，数据是[15:0]，那么也就是说这里面总线的最小寻址单元是1个16bits的半字，所以我们这个转换桥，还需要做一个32位到16位的工作，实际上这个avalon是32位的更方便，因为这样就不要我们转换桥做额外的工作了，但是当我设定16位宽的时候，sdram和总线接口都被固定为16位，不能修改。设定完这些后保存，在.bb中找到所有接口信号明确的位宽 module sdram ( avalon_sdram_address, avalon_sdram_byteenable_n, avalon_sdram_chipselect, avalon_sdram_writedata, avalon_sdram_read_n, avalon_sdram_write_n, avalon_sdram_readdata, avalon_sdram_readdatavalid, avalon_sdram_waitrequest, clk_clk, reset_reset_n, sdram_addr, sdram_ba, sdram_cas_n, sdram_cke, sdram_cs_n, sdram_dq, sdram_dqm, sdram_ras_n, sdram_we_n); input [21:0] avalon_sdram_address; input [1:0] avalon_sdram_byteenable_n; input avalon_sdram_chipselect; input [15:0] avalon_sdram_writedata; input avalon_sdram_read_n; input avalon_sdram_write_n; output [15:0] avalon_sdram_readdata; output avalon_sdram_readdatavalid; output avalon_sdram_waitrequest; input clk_clk; input reset_reset_n; output [11:0] sdram_addr; output [1:0] sdram_ba; output sdram_cas_n; output sdram_cke; output sdram_cs_n; inout [15:0] sdram_dq; output [1:0] sdram_dqm; output sdram_ras_n; output sdram_we_n; endmodule 有了这部分之后，下面开始总线转换桥的编写，参见wb32_avalon16代码，这里不具体分析，因为我也不确定是否完全正确，大致的思路是构建一个状态机，当wishbone总线上有请求时，也就是cyc和stb都为1，那么就开始进行转换工作，在开始之前，我有一个等待cnt的操作，出于担心时序的影响，因为setup time小于0，所以又等待了十几个sdram频率的周期。这里SDRAM主频150MHz,总线20MHz。 如果发现仍然有cyc和stb都为1，根据总线中we使能情况看是写请求还是读请求，对于读请求和写请求来说，都是通过先低16位后高16位的操作，对于avalon总线来说，对于写请求等待waitrequest拉低就可以，而读请求需要等readdatavalid拉高才可以。事实上应该有更快的响应方式，但此处我这里采用这种基本的握手规则。 需要注意的是avalon总线中关于read,write,和byteenable都是低有效的，准确的说应该是对于qsys中这个sdram是这样规定(低有效)的，所以处理的时候需要多加小心。 然后在顶层例化，并在pll中添加相关时钟即可，另外这里需要注意一点时钟的相位，lxs的工作里面sdram给出来了两个时钟，1个角度为0，一个角度为-68，这里配置的原因请参考IP核手册，我在查阅资料的时候发现确实需要相位不同，需要调整，这里直接采用lxs中的数值。 CONFIG控制器 正如前面所提到的，这里的CONFIG是为了与BBL兼容，里面包含了 硬件信息 timer中断 其中硬件信息通过如下方式嵌入到fpga中，这里的config_string_rom通过 ./wishbone_cyc10/config_string_rom 生成，已写好相关makeifle(感谢lkx等人的工作)，通过脚本把生成的指令转换成verilog语句。实际上当上电的时刻，cpu执行的第一条指令是 config_string_rom 里面的一条跳转指令，跳转到ROM地址即0x0001_0000，和x86的FFFF_0000的跳转有异曲同工之妙。 wire[`WishboneDataBus] mem[0:`DataMemNum-1]; `include\"config_string_rom/config_string_rom\" 定时器中断实际上会有两个寄存器，一个是当前的cycle保存寄存器，这里面是 mtime，另一个是阈值寄存器，超过这个阈值就会触发一个中断，这里面叫 mtimecmp ，该模块包含了这两个寄存器的读写功能，以及触发timer中断的相关设置。 uart控制器 uart帧格式比较简单，在本工程下，停止位1位，无校验位，波特率115200。 为了节约资源，目前的uart控制器只包含发送功能，且波特率硬件写死为115200(不符合UART16550协议)，(在仿真环境下为了加快速度，调成250_0000)。需要注意的是，uart在仿真的时候需要在接受端模拟一个串口。位于simulation/modelsim/wishbone_soc.vt，这个代码修改自lkx的工作，大体的意思是在每个比特发送的中间时刻进行采样，最后形成字节，并使用$write(\"%c\", rx_byte);从而回显在modelsim上。 如果需要修改波特率，除了在SOC中修改波特率外，仿真条件下，在测试文件也需要进行修改，主要是以下两个常量： localparam CfgDivider = 25000000/2500000; localparam CfgDividerMid = CfgDivider/2; 在下板的时候，可以用putty等软件进行串口回显。putty是一个轻量级的软件，简单好用，推荐 PLL控制器 在本工程中，使用quartus IP核配置进行配置，说明如下 信号名称 时钟频率 用途 clk 12MHz 板载晶振输入时钟 wishbone_clk 25MHz 系统总线时钟 cpu_clk 10MHz cpu时钟 这里的时钟频率并不是很高，主要是为了布线时消除时序违约，实际上可能可以再快一点也不会有WNS错误。 另外，PLL出来有一个 lock 信号，将它和复位信号进行与运算 assign reset_n = lock & rst_n; 可以避免一些时序问题。 注意没当修改总线频率之后，相应的uart模块中传递的参数也要修改(如下部分)，否则可能uart工作不正常。 wishbone_uart_lite #( .ClkFreq(25000000), `ifdef Simulation .BoundRate(2500000) `else .BoundRate(115200) `endif ) const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"Chap3/3-0-test.html":{"url":"Chap3/3-0-test.html","title":"第三章指令测试","keywords":"","body":"RISCV测例 对于测例来讲，我参考了部分zwp的工作，https://github.com/oscourse-tsinghua/undergraduate-zwpu2019 同时也结合了最新的RISCV测例 https://github.com/riscv/riscv-tools 需要注意的是，zwp的工作中使用的第三方软核picrov32并不能完善地支持特权级架构，并且有一些自定义的指令，所以第一个链接中针对该CPU进行了一些特定的宏定义。然而我采用的CPU是比较完善的，所以对于zwp的工作需要进行适当修改。 rv32ui指令(目前SDRAM测试并到这个测试下面) 对于普通的用户级指令，我们是可以借鉴在picrov32中用到的方法，将所有的test_case一个一个测试。rv32ui测例位于 ./test/rv32ui 下，直接make(默认的TARGET是rv32ui 或执行 make TARGET=rv32ui )即可生成相应的hex文件(并已经复制到quartus工程)，如果需要修改，需要注意的是以下几个位置： ./test/firmware/sections.ld 串口地址，ROM，RAM地址及大小 ./test/firmware/start.S 可以通过注释修改进行的测例(此时需要删除 /test/test中的对应文件) ./test/rv32ui/riscv_test.h 串口地址，即代码中0x02000000的部分 SDRAM 对于SDRAM而言，我单独创建了一个文件叫SDRAM.S，为什么这样呢，主要是想同时测sdram和指令，防止sdram对了其他指令又错的情况(好吧目前sdram自身就不对)。为了方便打印，我里面构造了一个很简单的函数print_uint32,输入及变动参数(我这里没有设置堆栈也就是直接改变寄存器的值，当然你也可以自己加如堆栈操作) #input a3 change:a0,a1,a2,a3,a4,t3 print_uint32: 但这引来一个新的问题，那就是因为如果你的SDRAM不能工作的话，你的push,pop的正确性也就无从谈起了，所以干脆不用显得逻辑更正确。 rv32si指令与rv32mi指令 支持M和S态特权级架构的原始测例位于 ./riscv-test/isa/ ，由于每个指令的异常处理，状态并不相同，而且指令总共也不多，故我这里就没有将他们整合到一起，我目前的方法是将这些生成的指令拷贝到 ./test/rvmsi/ 中，然后回到test目录下，执行 make TARGET=rv32mi-p-xxx 。 对于rv32si与rv32mi指令拷贝过来的就是elf格式的文件 所以这里完全是用的官方的文件，不过也进行了适当修改，如需修改则需要注意以下几个位置，原因同上。 ./riscv-test/env/p/link.ld ./riscv-test/env/p/riscv_test.h rv32ua指令 相比于基本的运算，跳转，访存指令，原子指令如果遇到问题，需要更多的背景知识才能更好地进行调试。这里根据相关手册，简单介绍一下测例中涉及到的指令。 由于本人对原子指令理解不是很深刻，可能下面两小节叙述有错误，若有不解留言或参考手册也可 AMO指令 AMO指令对内存中的操作数执行一个原子操作，并将目标寄存器设置为操作前的内存值。原子表示内存读写之间的过程不会被打断，内存值也不会被其它处理器修改。 在手册中有这样一个例子，实现互斥： li t0, 1 # Initialize swap value. again: amoswap.w.aq t1, t0, (a0) # Attempt to acquire lock. bnez t1, again # Retry if held. # ... # Critical section. # ... amoswap.w.rl x0, x0, (a0) # Release lock by storing 0. 首先初始化交换值，这里让t0等于1;然后执行amoswap操作，这条语句的意思原子地把内存memory[a0]的值先读取在t1中，将交换结果(即t0)重新保存到memory[a0]中，其中涉及到一次内存读与一次内存写，CPU保证读写之间不被打断。 aq,rl对于单处理器来说不必考虑，这里的交换只会改变位于memory[a0]的值，和寄存器t1的值，t0不会改变 如果t1(也就是原先的memory[a0])不等于0，就会重新请求(等待其他线程释放资源)，否则就执行临界区代码。此时memory[a0]会置为1，等到最后一条语句的时候会释放。 LR/SC指令 LR/SC指令保证了它们两条指令之间的操作的原子性。LR读取一个内存字，存入目标寄存器中，并留下这个字的保留记录。而如果SC的目标地址上存在保留记录，它就把字存入这个地址。如果存入成功，它向目标寄存器中写入0；否则写入一个非0的错误代码。 同样的，手册中也有一个例子，实现原子交换比较： # a0 holds address of memory location # a1 holds expected value # a2 holds desired value # a0 holds return value, 0 if successful, !0 otherwise cas: lr.w t0, (a0) # Load original value. bne t0, a1, fail # Doesn’t match, so fail. sc.w t0, a2, (a0) # Try to update. bnez t0, cas # Retry if store-conditional failed. li a0, 0 # Set return to success. jr ra # Return. fail: li a0, 1 # Set return to failure. jr ra # Return. 首先从memory[a0]中取出数据至t0，如果和预期的不符合那就直接到fail了，如果和预期的值a1相符，则继续执行 sc.w语句，尝试将a2写入到memory[a0]，并将结果保存至t0，对于本条SC指令来说，结果保存到t0，如果成功t0就是0，否则是一个非0的数；接下来语句 bnez 意思是如果t0不是0，也就是SC失败了，那么重新调到cas执行，否则就代表成功，可以返回了。 rv32ua指令测试 rv32ua指令的测试方法与rv32ui类似，执行 make TARGET=rv32ua 即可 测例详解 由于测例都是通过宏来封装的，所以就有必要搞清楚这些宏的工作原理以便排查问题和增添测例。下面以 addi.S 为例进行一些说明 #include \"riscv_test.h\" #include \"test_macros.h\" RVTEST_RV32U RVTEST_CODE_BEGIN 打开 addi.S 文件后，看到在真正的测例宏前有如下几行，其中 riscv_test 包含了一些测试初始化，打印PAST，FAIL的宏，而 test_macros.h 则包含了不同指令测试的宏。，具体之后还会有例子。 下面 RVTEST_RV32U 代表这是32位的测例，因为 riscv-test 只有在64位下才有真正的源代码，32位只是借用了64位的测例，并通过宏的形式进行少量修改，因为要测试的是32位指令集，所以要有这个。 RVTEST_CODE_BEGIN 是来自于 riscv_test.h #define RVTEST_CODE_BEGIN \\ .text; \\ .global TEST_FUNC_NAME; \\ .global TEST_FUNC_RET; \\ TEST_FUNC_NAME: \\ li a0, 0x00ff; \\ .delay_pr: \\ addi a0,a0,-1; \\ bne a0,zero,.delay_pr; \\ lui a0,%hi(.test_name); \\ addi a0,a0,%lo(.test_name); \\ lui a2,0x02000000>>12; \\ .prname_next: \\ lb a1,0(a0); \\ beq a1,zero,.prname_done; \\ sw a1,0(a2); \\ addi a0,a0,1; \\ jal zero,.prname_next; \\ .test_name: \\ .ascii TEST_FUNC_TXT; \\ .byte 0x00; \\ .balign 4, 0; \\ .prname_done: \\ addi a1,zero,'.'; \\ sw a1,0(a2); \\ sw a1,0(a2); .delay_pr是一个延时，原先可能是0xffff或者一个更大的数，但是在仿真下回消耗很大不必要的时间，这里我给调小了点，这部分是打印功能测试的名字，对于本例是addi..，之后就进入了真正的测例 #------------------------------------------------------------- # Arithmetic tests #------------------------------------------------------------- TEST_IMM_OP( 2, addi, 0x00000000, 0x00000000, 0x000 ); TEST_IMM_OP( 3, addi, 0x00000002, 0x00000001, 0x001 ); TEST_IMM_OP( 4, addi, 0x0000000a, 0x00000003, 0x007 ); TEST_RP_OP 是一个宏，这个宏的定义如下 #define TEST_IMM_OP( testnum, inst, result, val1, imm ) \\ TEST_CASE( testnum, x3, result, \\ li x1, val1; \\ inst x3, x1, SEXT_IMM(imm); \\ ) 宏的声明不难理解，内容则是调用另一个宏TEST_CASE，其中SEXT_IMM(imm)是 #define SEXT_IMM(x) ((x) | (-(((x) >> 11) & 1) 而TEST_CASE定义如下： #define TEST_CASE( testnum, testreg, correctval, code... ) \\ test_ ## testnum: \\ code; \\ li x29, correctval; \\ li TESTNUM, testnum; \\ bne testreg, x29, fail; 追踪到TEST_CASE 一上来是一个声明第一个test，test_ ## testnum 将会被展开成 test_1 test_2 的形式, 之后code则是通过TEST_IMM_OP传进来的，这里是一个可变参量，所以可以有多条语句。之后将比对运算结果是否是正确的即 testreg 的数值是否和 correctval 相等，如果不相等就跳转到失败，打印\"FAIL\"然后返回。 将宏TEST_IMM_OP对于本例进行展开就是 li x1, 0x00000000, addi x3, x1, SEXT_IMM(0) li x29, 0 li TESTNUM, 2 bne x3, x29, fail 即验证0 + 0 ?= 0 const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"Chap4/4-0-bbl.html":{"url":"Chap4/4-0-bbl.html","title":"第四章bbl分析","keywords":"","body":"bbl启动流程分析 Berkeley Boot Loader (BBL) 是 M 态的程序，可以引导我们移植的 BBL-uCore以及 linux等操作系统。其基本上可以认为是硬件/软件的接口，无论是对于操作 系统的移植，还是对于 RISC-V 的硬件设计，都是同等的重要的。下面简要介绍 BBL 所完成的功能。(以下工作部分参考了lkx的报告) step1 相关代码： ./machine/mentry.S ./machine/minit.c 在运行BBL之前，首先应将BBL置于内存0x8000_0000之后的位置，0x8000_0000处对应的时./machine/mentry.S中的一条跳转到do_reset指令。之后跳转到do_reset时首先进行的是寄存器清零，置mscratch为0。接下来将mtvec设置为trap_vector的地址，并进行检测。设置sp为binary最后的位置(页对齐)，跳转到 init_first_hart 。对应代码如下： 似乎markdown还不支持riscv汇编，所以目前只能没有高亮显示了 do_reset: # 清空reg li x1, 0 li x2, 0 li x3, 0 li x4, 0 li x5, 0 li x6, 0 li x7, 0 li x8, 0 li x9, 0 li x10, 0 li x11, 0 li x12, 0 li x13, 0 li x14, 0 li x15, 0 li x16, 0 li x17, 0 li x18, 0 li x19, 0 li x20, 0 li x21, 0 li x22, 0 li x23, 0 li x24, 0 li x25, 0 li x26, 0 li x27, 0 li x28, 0 li x29, 0 li x30, 0 li x31, 0 # 清空mscratch csrw mscratch, x0 # 设置mtvec为trap_vector并检测 la t0, trap_vector csrw mtvec, t0 csrr t1, mtvec 1:bne t0, t1, 1b # 设置sp位整个binary末尾处，并且是页对齐的 la sp, _end + 2*RISCV_PGSIZE - 1 li t0, -RISCV_PGSIZE and sp, sp, t0 addi sp, sp, -MENTRY_FRAME_SIZE csrr a0, mhartid slli a1, a0, RISCV_PGSHIFT add sp, sp, a1 # 跳转到 init_first_hart beqz a0, init_first_hart step2 跳转到 init_first_hart 这个C语言函数后，进行了一些列初始化的工作，包括M态的一些csr设置，fp初始化，解析在地址0x00001000处的config_string，初始化中断，初始化内存单元，及以上相关操作的检测，最后是加载OS，具体函数位于 ./machine/minit ./machine/ 实际上这个config_string我为了降低仿真时间，大部分都直接在软件写死了。 void init_first_hart() { hart_init(); hls_init(0); // this might get called again from parse_config_string parse_config_string(); plic_init(); hart_plic_init(); prci_test(); unaligned_r_w_test(); memory_init(); memory_check(); boot_loader(); } 由于代码较多故以总结的形式列举如下，详细请参考源码 在 hart_init 中，主要涉及几个函数 mstatus_init， fp_init， delegate_traps mstatus_init ： // 设置页表映射模式 mstatus.VM = VM32 mstatus.FS= 1 // 使能S态和U态的性能检测(似乎没啥用) mucounteren = -1 mscounteren = -1 // 禁止时钟中断，允许其他类型的中断 mie = ~MIP_MTIP fp_init: //清空misa中关于'F'与'D'的描述 misa.'F' = 0; misa.'D' = 0; misa是一个反映这个处理器支持那些ISA的一个M态的csr 'F'的定义是 单精度的浮点拓展 'D'的定义是 双精度的浮点拓展 关于更多的资料请查阅riscv特权级手册中的描述(但个人感觉此处并非很重要，知道设置为0就可以了) delegate_traps: // 将S态的中断和大多数的异常都给S态处理 mideleg = MIP_SSIP | MIP_STIP | MIP_SEIP medeleg = (1U 需要注意的是，对于有些异常，还是交由M态处理的(就是那些mideleg和medeleg没有置0的位对应的异常中断)，因为实际上这个cpu的页表替换功能不是很健全，需要软件的协助，这部分的软件实际上位于bbl，也就是说当发生某些异常如page_fault的时候，操作系统会维护一些部分，bbl也会维护一些部分，硬件做的是只是读/写对应的tlb表项，而硬件并不会自主替换哪个页表(比如替换算法就是bbl来维护的)，这一点与原来的bbl不一样需要特别留意，否则无法理解整个系统的运作。 此后进入到 hls_init ，但由于这个函数会被parse_config再调用一次，所以等之后一起分析， parse_config_string: 这个函数的主要功能就是读取位于0x0000_1000中的一些config然后软件进行相应的设置，为了节省启动时间与fpga的空间，我对此部分进行了一定优化，具体说来就是在bbl写死这些config的值，而不是从硬件上去读取。因为无论如何总归要在硬件上或者软件上指定这些参数(SDRAM的起始位置，大小，UART地址等)，所以个人认为从软件上写死不仅可以节省查询config的时间，而且也节省了fpga的资源，也加快了仿真的进度。 代码位于： 我使用的板子逻辑资源只有15.5k，当我综合这个SOC的时候，已经用了15k(98%).. 这还是在进行了一些优化的情况下 所以能省则省.. 举个例子来讲，对于 query_mem 这个函数而言，他希望获取的是ram的地址和大小，所以我们通过注释掉query_config_string相关操作，就可以不必从硬件上获取，而是直接幅值即可，其余的query函数以此类推。 static void query_mem(const char* config_string) { //query_result res = query_config_string(config_string, \"ram{0{addr\"); //assert(res.start); //uintptr_t base = get_uint(res); uintptr_t base = (uintptr_t)0x80000000; assert(base == DRAM_BASE); //res = query_config_string(config_string, \"ram{0{size\"); //mem_size = get_uint(res); mem_size = (uint64_t)0x00400000; } hart_plic_init： 主要目的是清除中断 *HLS()->ipi = 0; *HLS()->timecmp = -1ULL; write_csr(mip, 0); memory_init： 计算mem_size和第一个未被占用的物理地址 mem_size = mem_size / MEGAPAGE_SIZE * MEGAPAGE_SIZE; first_free_paddr = sbi_top_paddr() + num_harts * RISCV_PGSIZE; step3 boot_loader 进行完以上的初始化任务后，进入到boot_loader函数中，首先打印loading OS的字符串，接下来进入load_kernel_elf这个函数加载elf格式的OS，然后是S态支持虚拟内存的一些初始化过程，接下来打印logo，刷tlb，最终进入到S态的OS中，至此所有的bootloader工作全部结束，控制权交给OS kernel。 代码位于 . ./bbl/bbl.c ./bbl/kernel_elf.c ./bbl/elf.h log(\"machine mode: loading payload OS...\"); extern char _payload_start, _payload_end; load_kernel_elf(&_payload_start, &_payload_end - &_payload_start, &info); supervisor_vm_init(); print_logo(); mb(); elf_loaded = 1; enter_supervisor_mode((void *)info.entry, 0); load_kernel_elf: 加载os 这里简单介绍elf文件，不是重点，在 ./bbl/elf.h 文件中，elf文件格式定义如下： typedef struct { uint8_t e_ident[16]; uint16_t e_type; uint16_t e_machine; uint32_t e_version; uint32_t e_entry; uint32_t e_phoff; uint32_t e_shoff; uint32_t e_flags; uint16_t e_ehsize; uint16_t e_phentsize; uint16_t e_phnum; uint16_t e_shentsize; uint16_t e_shnum; uint16_t e_shstrndx; } Elf32_Ehdr; 一开始的几个结构从e_ident到e_version都是存储的关于文件格式信息，在load_kernel_elf这个函数开始进行了相关检查，包含头格式，物理地址大小等。(如果最终采取的是4KB映射，所以此时修改了第一个空闲物理地址的起始位置时页对齐，而不是巨页对齐。) first_free_paddr = ROUNDUP(first_free_paddr, RISCV_PGSIZE); 之后函数通过检测所有的加载段，来获取最小的虚拟地址。然后进行段的复制(从物理地址到虚拟地址的位置，实际上应该是从物理地址A到虚拟地址所映射的物理地址B的复制，不过此时还没映射，但可以看作是上面那句话)，这样设置完页表就可以进入到e_entry执行程序了。所以执行程序之前还需要进行一些M态的设置， superviosr_vm_init:页表设置 这也就是supervisor_vm_init函数的工作，最关键的是设置页表的映射，另外需要注意的是最后需要把sbi映射到虚地址的最顶端部分。 uintptr_t num_sbi_pages = ((uintptr_t)&_sbi_end - DRAM_BASE - 1) / RISCV_PGSIZE + 1; assert(num_sbi_pages > RISCV_PGSHIFT); //最终映射sbi_pt到root_pt上 这部分都是一些页表的操作，还是建议通过阅读源码理解清楚(Ps: 实际上这里不映射也行的，因为ecall也是交由M态处理了qaq) 在函数最后刷新sptbr也就是satp,之后便进入到S态的os中了。 bbl对TLB的支持实现 仅仅是了解了启动流程还是不够的，我们需要关注一些软硬件配合的细节，这里需要强调一点是由于硬件并没有完全控制tlb的过程，所以实际上是由软件维护tlb的，比如tlb满的时候究竟要换哪个页。这个tlb表项要写入的数值是什么等等。 首先我们来看 ./machine/mentry.S这个文件， trap_table: .word bad_trap .word tlb_i_miss_trap .word illegal_insn_trap .word bad_trap .word misaligned_load_trap .word tlb_r_miss_trap .word misaligned_store_trap .word tlb_w_miss_trap 代码一开始就是一个trap_table里面储存着各个trap的处理程序，举个例子，对于tlb_i_miss_trap而言,他对应的函数位于./machine/emulation.c中: void tlb_i_miss_trap(uintptr_t* regs, uintptr_t mcause, uintptr_t mepc) { tlb_miss_trap(regs, mcause, mepc, 1, 0, 0); } 我们目前先不关心这个函数究竟干什么了，只需要知道这个trap_table是存储的各种trap的处理程序的地址就可以。由于这些trap都是在m态被触发的，结合RISCV的架构，我们知道有一个mtvec的寄存器十分关键，在处理器m态下发生异常时，硬件会根据mtvec跳转到相应的地址，那么在bbl中mtvec被设置成什么了呢？实际上就在./machine/mentry.S中 la t0, trap_vector csrw mtvec, t0 这里我们看到，bbl把trap_vector赋值给了mtvec,而trap_vector也在这个文件中，对应代码如下: trap_vector: csrrw sp, mscratch, sp beqz sp, .Ltrap_from_machine_mode # 这里也是最终跳转到.Lhandle_trap_in_machine_mode中的 STORE a0, 10*REGBYTES(sp) STORE a1, 11*REGBYTES(sp) csrr a1, mcause bgez a1, .Lhandle_trap_in_machine_mode # This is an interrupt. Discard the mcause MSB and decode the rest. sll a1, a1, 1 # Is it a machine timer interrupt? li a0, IRQ_M_TIMER * 2 bne a0, a1, 1f li a1, TIMER_INTERRUPT_VECTOR j .Lhandle_trap_in_machine_mode 这里我们看到根据中断异常不同的类型，最终都会跳转到 .Lhandle_trap_in_machine_mode中 .Lhandle_trap_in_machine_mode: # Preserve the registers. Compute the address of the trap handler. STORE ra, 1*REGBYTES(sp) STORE gp, 3*REGBYTES(sp) STORE tp, 4*REGBYTES(sp) STORE t0, 5*REGBYTES(sp) 1:auipc t0, %pcrel_hi(trap_table) # t0 可以看到根据mcause选择相应的trap_table的偏移量(即对应哪个trap处理程序),t1最终就指向了对应的处理程序的地址，最终一个jalr就跳转过去了。 现在我们就大致搞清了，当发生一个trap的时候，究竟bbl哪部分在起作用，整个流程是如何的。当我们的操作系统在S态发生一个tlb_i_miss的时候，会出现一个strap，着个strap由于medeleg的设置对应位是0，所以交给了M态处理，处理的函数就是trap_vector，根据mcause里面对应的trap，软件会知道这个是一个tlb_i_miss，进行一些跳转前的保护寄存器的工作后，就跳转到这个trap_table里面对应的tlb_i_miss的地址上去执行了，执行完毕后，就恢复寄存器最后执行mret就可以了。 下一步我们来看看究竟tlb_i_miss中间bbl干了什么(这部分是原来bbl没有的，大部分程序都是由lkx添加的) tlb_miss_trap 首先无论是指令缺失还是数据缺失最终都会引到tlb_miss_trap中,只不过属性值不太一样而已: void tlb_i_miss_trap(uintptr_t* regs, uintptr_t mcause, uintptr_t mepc) { tlb_miss_trap(regs, mcause, mepc, 1, 0, 0); } void tlb_r_miss_trap(uintptr_t* regs, uintptr_t mcause, uintptr_t mepc) { tlb_miss_trap(regs, mcause, mepc, 0, 1, 0); } void tlb_w_miss_trap(uintptr_t* regs, uintptr_t mcause, uintptr_t mepc) { tlb_miss_trap(regs, mcause, mepc, 0, 0, 1); } 这个函数tlb_miss_trap是控制tlb的核心,我们首先看下这个函数的原型: void tlb_miss_trap(uintptr_t* regs, uintptr_t mcause, uintptr_t mepc, int ex, int rd, int wt) 还是比较好顾名思义的，所谓regs，就是寄存器的地址, mcause, mepc就是csr中的数值，不过需要注意的是，这里的regs, mcause都已经被实实在在地存储在内存中某个地方，而不是硬件中地某个LUT,FF，这点需要搞清楚。 一个自然的问题是他们是怎么完成硬件到内存这样一个过程呢，其实就是在刚刚地.Lhandle_trap_in_machine_mode:完成了，我们再来回头看一下: ... csrr a1, mcause ... STORE s1, 9*REGBYTES(sp) mv a0, sp # a0 实际上regs(所对应的堆栈sp)和mcause, mepc已经被保存到 a0, a1, a2上了，根据cdecl调用规则和riscv的寄存器调用规则我们就可以知道，当调用这个tlb_miss_trap函数的时候，a2, a1, a1(从右到左)会被依次压栈，然后tlb_miss_trap进入这个函数的时候就会依次pop出来使用了。 这部分可以更多看看手册，有大致概念就可以 好了我们正式看这个tlb_miss_trap函数了: 首先获取 mstatus中vm的数值以方便知道是用的RV_32页表还是其他的，然后根据__riscv_xlen的数值,判断是32位还是64位的系统，从而获取相应的页表基地址。这部分代码如下: uintptr_t mstatus = read_csr(mstatus); uint32_t vm = (EXTRACT_FIELD(mstatus, MSTATUS_VM)); #if __riscv_xlen == 32 uint32_t p = 32; uintptr_t a = ((read_csr(sptbr)) & ((1 我们这里是VM32，lever2意思是两级页表，ptesize是每个页表的字节数，对于32位os是4字节，vpn长度是10。这里如果对riscv页表不太熟悉可以看看 https://learningos.github.io/rcore_step_by_step_webdoc/docs/%E9%A1%B5%E8%A1%A8%E7%AE%80%E4%BB%8B.html 或者是riscv中文手册 for (i = levels - 1; ; i --) { p -= vpnlen; // p = 32 - 10 = 22 // 之前mask = 0 mask = ~((~mask) >> vpnlen); //这行之后mask = 1111_1111_1000_00...._0000 uintptr_t vpn = ((va >> p) & ((1 当第一次进入这个循环的时候, a就是上文中对应的root_page_table 找到的pte, 而pte_p就代表这个虚拟地址对应的一级页表的地址，然后pte就是一级页表(或者叫巨页)，页目录项的值了。 进行一些检查之后，如果当前页表的内容是指向下一级的(X W R均为0)，那么更新a位当前pte对应的页表项基址: if ((pte & (PTE_X | PTE_W | PTE_R)) == 0) { a = (pte >> 10) 好了接下来涉及到一些硬件自定义的csr寄存器，这里需要结合着verilog代码来看: 涉及到的寄存器主要及功能如下表： CSR寄存器数值 对应硬件宏 0x7c0 CSR_mtlbindex 0x7c1 CSR_mtlbvpn 0x7c2 CSR_mtlbmask 0x7c3 CSR_mtlbpte 0x7c4 CSR_mtlbptevaddr 根据硬件宏的名字，应该直接能大致推断出来什么意思，好了有了大概的认知,我们接下来看这段程序: pte |= PTE_A; if(wt) pte |= PTE_D; *pte_p = pte; 首先置access位，如果是write的话把dirty位页置1。 if(((uintptr_t)read_csr(0x7c0)) >> (__riscv_xlen - 1)) { uintptr_t index_old = read_csr(0x7c0); uintptr_t va_old = read_csr(0x7c1); uintptr_t mask_old = read_csr(0x7c2); uintptr_t pte_old = read_csr(0x7c3); uintptr_t *pte_p_old = (uintptr_t *)read_csr(0x7c4); 这里0x7c0代表的是mtlbindex，如果mtlbindex最高位是1的话就更新，结合硬件看一下: `ifdef RV32 `define CSR_mtlbindex_update_bus 31:31 `else `CSR_mtlbindex: begin data_o[`CSR_mtlbindex_bus] 当我们读0x7c0的CSR的时候，实际上就是CSR_mtlbindex那条Verilog语句，这里的CSR_mtlbindex_update_bus就是31，就和软件bbl对应上了。然后分别把这几个csr寄存器读出来。做一些检查之后,进行更新: *pte_p = pte; write_csr(0x7c3, pte); write_csr(0x7c0, index_old); assert(read_csr(0x7c0) == (index_old > 1); return; }// 结束if 注意以上部分(if里)更新的是hit了，但是没有A标志位，或者是写操作但是D标志位是0的情况,结合verilog代码我们看到如下语句: update_exception[i] 而update_exception则是: if(tlb_miss_exception) tlb_update_o 所以只会在没有miss的时候，update才会发生，也就是上面这些行为。那么miss的处理过程如下: write_csr(0x7c0, index); write_csr(0x7c1, va & mask); write_csr(0x7c2, mask); write_csr(0x7c3, pte); write_csr(0x7c4, pte_p); index += 1; return; 注意此时的index是一个static变量，所以这个替换过程是一个简单的fifo。另外对于sfence.vm的处理，则是把它当作指令缺失地异常处理，最终的思想是相似的，如果理解了tlb替换的过程，sfence.vma的替换想必也可明白。 const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"chap5/5-0-os.html":{"url":"chap5/5-0-os.html","title":"第五章OS分析","keywords":"","body":" const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"Chap6/6-0-result.html":{"url":"Chap6/6-0-result.html","title":"附录","keywords":"","body":"测试结果 rv32ui测试效果 仿真效果图如下： 下板效果图如下： RV32ua测试结果 仿真效果图如下： 下板效果图如下： const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '8c56e9dae52cf0da1582', clientSecret: '5dc33ee4d70a65898c90f64836a44e63d25ff747', repo: 'cyc10-rcore-tutorial', owner: 'moon548834', admin: ['moon548834'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "}}